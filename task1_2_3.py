import networkx as nx
import matplotlib.pyplot as plt
from collections import deque

# Областные центры Украины и их приближенные координаты на карте (откорректируйте по необходимости)
cities_coords = {
    "Київ": (30.52, 50.45),
    "Харків": (36.25, 49.98),
    "Дніпро": (35.04, 48.45),
    "Одесса": (30.73, 46.48),
    "Львів": (24.03, 49.84),
    "Запоріжжя": (35.18, 47.84),
    "Кривий Ріг": (33.35, 47.91),
    "Кропивницький": (32.16, 48.30),
    "Миколаїв": (31.98, 46.97),
    "Маріуполь": (37.53, 47.10),
    "Вінниця": (28.48, 49.23),
    "Херсон": (32.62, 46.63),
    "Чернігів": (31.29, 51.50),
    "Полтава": (34.53, 49.58),
    "Черкаси": (32.06, 49.44),
    "Суми": (34.80, 50.91),
    "Рівно": (26.25, 50.62),
    "Хмельницький": (26.98, 49.42),
    "Чернівці": (25.94, 48.29),
    "Житомир": (28.65, 50.25),
    "Тернопіль": (25.59, 49.55),
    "Луцьк": (25.33, 50.74),
    "Івано-Франківськ": (24.71, 48.92),
    "Ужгород": (22.30, 48.62),
    "Луганськ": (39.30, 48.57),
    "Донецьк": (37.80, 48.00),
    "Сімферополь": (34.11, 44.95),
}

# Расстояния (в километрах по прямой линии как приближение)
edges = [
    ("Київ", "Харків", 479),
    ("Київ", "Одесса", 476),
    ("Київ", "Дніпро", 480),
    ("Київ", "Черкаси", 192),
    ("Київ", "Вінниця", 246),
    ("Київ", "Житомир", 139),
    ("Київ", "Чернігів", 155),
    ("Київ", "Полтава", 350),
    ("Київ", "Суми", 332),
    ("Житомир", "Рівно", 190),
    ("Рівно", "Луцьк", 73),
    ("Рівно", "Львів", 211),
    ("Львів", "Луцьк", 152),
    ("Львів", "Тернопіль", 127),
    ("Львів", "Івано-Франківськ", 135),
    ("Львів", "Ужгород", 248),
    ("Ужгород", "Івано-Франківськ", 270),
    ("Чернівці", "Івано-Франківськ", 135),
    ("Тернопіль", "Івано-Франківськ", 132),
    ("Тернопіль", "Хмельницький", 112),
    ("Тернопіль", "Рівно", 154),
    ("Вінниця", "Хмельницький", 119),
    ("Вінниця", "Чернівці", 284),
    ("Вінниця", "Житомир", 153),
    ("Вінниця", "Кропивницький", 321),
    ("Вінниця", "Одесса", 425),
    ("Харків", "Дніпро", 213),
    ("Дніпро", "Запоріжжя", 70),
    ("Дніпро", "Кривий Ріг", 146),
    ("Дніпро", "Донецьк", 249),
    ("Дніпро", "Черкаси", 321),
    ("Одесса", "Миколаїв", 135),
    ("Миколаїв", "Херсон", 67),
    ("Миколаїв", "Кривий Ріг", 175),
    ("Миколаїв", "Кропивницький", 183),
    ("Кривий Ріг", "Кропивницький", 119),
    ("Дніпро", "Полтава", 197),
    ("Полтава", "Харків", 143),
    ("Полтава", "Суми", 176),
    ("Черкаси", "Кропивницький", 129),
    ("Харків", "Суми", 186),
    ("Харків", "Донецьк", 336),
    ("Харків", "Луганськ", 339),
    ("Херсон", "Сімферополь", 267),
    ("Херсон", "Маріуполь", 423),
    ("Донецьк", "Луганськ", 155),
    ("Донецьк", "Маріуполь", 121),
    ("Запоріжжя", "Маріуполь", 239),
]

G = nx.Graph()

# Добавляем вершины с координатами
for city, (x, y) in cities_coords.items():
    G.add_node(city, pos=(x, y))

# Добавляем ребра с весами (расстояниями)
for city1, city2, distance in edges:
    G.add_edge(city1, city2, weight=distance)

# Получаем позиции вершин
pos = nx.get_node_attributes(G, 'pos')

# Рисуем граф
plt.figure(figsize=(15, 10))
nx.draw(G, pos, with_labels=True, node_size=500, node_color='skyblue', font_size=10, font_weight='bold', edge_color='gray')
labels = nx.get_edge_attributes(G, 'weight')
nx.draw_networkx_edge_labels(G, pos, edge_labels=labels)
plt.grid(True)
plt.title("Граф областных центров и крупных городов Украины и автомобильных магистралей между ними")
plt.show()

# Анализ характеристик графа
num_nodes = G.number_of_nodes()
num_edges = G.number_of_edges()
average_degree = sum(dict(G.degree()).values()) / num_nodes

print(f"Кількість вершин: {num_nodes}")
print(f"Кількість ребер: {num_edges}")
print(f"Середній ступінь вершин: {average_degree}")
print("")

# Алгоритм Дейкстры
shortest_paths = nx.single_source_dijkstra_path(G, source="Київ")
shortest_path_lengths = nx.single_source_dijkstra_path_length(G, source="Київ")

print(f"Довжини найкоротших шляхів: {shortest_path_lengths}")
print(f"Найкоротші шляхи від Київа до інших вершин:")
for node, distance in shortest_paths.items():
    print(f"{node}: {distance}")
print("")


# алгоритм DFS
def dfs_recursive(graph, vertex, visited=None):
    if visited is None:
        visited = set()
    visited.add(vertex)
    result = [vertex]  # Відвідуємо вершину
    for neighbor in graph[vertex]:
        if neighbor not in visited:
            result += dfs_recursive(graph, neighbor, visited)
    return result

dfs_result = dfs_recursive(G, "Київ")
print("DFS Result:", dfs_result)


# алгоритм BFS
def bfs_recursive(graph, queue, visited=None):
    # Перевіряємо, чи існує множина відвіданих вершин, якщо ні, то ініціалізуємо нову
    if visited is None:
        visited = set()
    result = [] #створюємо пустий список result, де зберігаємо результати обходу графа
    while queue:
        vertex = queue.popleft()
        if vertex not in visited:
            result.append(vertex)
            visited.add(vertex)
            queue.extend(set(graph.neighbors(vertex)) - visited)
    return result

bfs_result = bfs_recursive(G, deque(["Київ"]))
print("BFS Result:", bfs_result)
